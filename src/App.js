import './App.css';
import React from 'react'
import { BrowserRouter as Router, Switch, Route} from 'react-router-dom'
import Home from './views/home/home.js';
import Login from './views/login/login';
import Register from './views/register/register';
import Logout from './views/logout/logout';
import MenuBar from './components/MenuBar/MenuBar'
import Dashboard from './views/dashboard/dashboard';
import MetinClient from './views/client/MetinClient';
import store from './store';
import { w3cwebsocket as W3CWebSocket } from 'websocket'
import {ACTIONS} from './utils/enums.js'
import { PrivateRoute } from './PrivateRoute';
import SchemaCreator from "./views/schema_creator/schema_creator";
import { connect } from 'react-redux';

class App extends React.Component {
  constructor(props) {
    super(props)
    this.SocketToLocalServer = new W3CWebSocket('ws://localhost:13254')
    this.SocketToLocalServer.onmessage = this.OnMessage
    this.SocketToLocalServer.onopen = this.OnOpen
  }

  OnOpen = () => {
    store.dispatch({type: ACTIONS.SET_AS_FRONTEND, client: this.SocketToLocalServer})
  }

  OnMessage = (data) => {
    const cleared_data = (function(data) {
      try{
        return JSON.parse(data.data)
      }catch(err){
        
        return false
      }
    })(data)
    console.log(cleared_data)
    
    //console.log(cleared_data)

    if (cleared_data.type == 'information'){

      if (cleared_data.data.action == ACTIONS.GET_ALL_CONNECTED_METIN_CLIENTS){
        console.log(cleared_data.data.message)
        this.onReceiveMetinClients(cleared_data.data.message)
      }
      else if (cleared_data.data.action == ACTIONS.GET_FULL_CHARACTER_STATUS){
        this.onReceiveCharacterStatus(cleared_data.data.message)
      }
      else if (cleared_data.data.action == ACTIONS.GET_FULL_INSTANCES_LIST){
        //console.log(cleared_data.data.message)
        this.onReceiveInstancesList(cleared_data.data.message)
      }
      else if (cleared_data.data.action == ACTIONS.GET_FULL_HACK_STATUS){
        //console.log(cleared_data.data.message)
        this.onReceiveHackStatus(cleared_data.data.message)
      }
      else if (cleared_data.data.action == ACTIONS.GET_FULL_SERVER_STATUS){
        this.onReceiveServerStatus(cleared_data.data.message)
      }
      else if (cleared_data.data.action == ACTIONS.SET_INVENTORY_STATUS){
        //console.log(cleared_data.data.message)
        this.onRevceiveInventoryStatus(cleared_data.data.message)
      }      
      else if (cleared_data.data.action == ACTIONS.SET_PICKUP_FILTER){
        //console.log(cleared_data.data.message)
        this.OnReceivePickupFilter(cleared_data.data.message)
      }  
    }

  }

  onRevceiveInventoryStatus = (inventory_list) => {
    store.dispatch({type: ACTIONS.SET_INVENTORY_STATUS, payload: inventory_list})
  }
  OnReceivePickupFilter = (pickup_filter) => {
    store.dispatch({type: ACTIONS.SET_PICKUP_FILTER, payload: pickup_filter})
  }
  onReceiveMetinClients = (metin_clients_list) => {
    store.dispatch({type: ACTIONS.SET_METIN_CLIENTS, payload: metin_clients_list})
    //console.log(store.getState())
  }

  onReceiveCharacterStatus = (character_status) => {
    store.dispatch({type: ACTIONS.SET_CHARACTER_STATUS, payload: character_status})
    //console.log(store.getState())
  }
  onReceiveInstancesList = (instances_list) => {
    store.dispatch({type: ACTIONS.SET_INSTANCES_LIST, payload: instances_list})
    //console.log(store.getState())
  }
  onReceiveHackStatus = (hack_status) => {
    store.dispatch({type: ACTIONS.SET_HACK_STATUS, payload: hack_status})
  }
  onReceiveServerStatus = (server_status) => {
    //console.log(server_status)
    store.dispatch({type: ACTIONS.SET_FULL_SERVER_STATUS, payload: server_status})
  }

  reRender() {
    this.forceUpdate()
  }

  componentDidMount() {
    store.dispatch({type: 'LOAD_LANGUAGE_FROM_STORAGE'})
  }

//<PrivateRoute exact path='/schema_creator' component={SchemaCreator} socket={this.SocketToLocalServer}/>
  render () {
          return (
            <Router>
              <MenuBar language={this.props.language.menubar} socket={this.SocketToLocalServer}/>
              <Switch>
                  <PrivateRoute exact path='/client' component={MetinClient} socket={this.SocketToLocalServer} language={this.props.language}/>
                  <PrivateRoute exact path='/dashboard' component={Dashboard} socket={this.SocketToLocalServer}
                                clients={store.getState().receivePacketsReducer.clients} language={this.props.language.dashboard}
                                metinclientslist_language={this.props.language.metinclientslist}/>
                  <Route path='/logout'> <Logout _render={() => this.reRender()}/> </Route>
                  <Route path='/login'> <Login _render={() => this.reRender()} language={this.props.language.login} description_language={this.props.language.loginregisterdesc}/></Route>
                  <Route path='/signup'> <Register language={this.props.language.register} description_language={this.props.language.loginregisterdesc}/> </Route>
                  <Route exact path='/'> <Home language={this.props.language.homepage}/> </Route>
              </Switch>
            </Router>
          );
        }
}
function mapStateToProps(state){
  //console.log(state)
  return {
    language: state.languageReducer.language
  }
}

export default connect(mapStateToProps)(App);
