import { ButtonTypes, Canvas, Circle, Rect, Text } from '@bucky24/react-canvas'
import {
    Layer,
    LayerImage,
    LayerRaw,
    Map
}                                                  from '@bucky24/react-canvas-map'
import {
    AccordionDetails,
    AccordionSummary,
    ButtonGroup,
    Grid,
    IconButton,
    Menu,
    MenuItem,
    Typography
}                                                  from '@material-ui/core';
import { GpsFixed }                                from '@material-ui/icons'
import MenuIcon                                    from '@material-ui/icons/Menu'
import React                                       from 'react'
import map_a2                                      from '../../images/maps/map_a2.jpg'
import map_n_snowm_01                              from '../../images/maps/map_n_snowm_01.jpg'
import metin2_guild_village_01                     from '../../images/maps/metin2_guild_village_01.jpg'
import metin2_guild_village_02                     from '../../images/maps/metin2_guild_village_02.jpg'
import metin2_guild_village_03                     from '../../images/maps/metin2_guild_village_03.jpg'
import metin2_map_a1                               from '../../images/maps/metin2_map_a1.jpg'
import metin2_map_a3                               from '../../images/maps/metin2_map_a3.jpg'
import metin2_map_b1                               from '../../images/maps/metin2_map_b1.jpg'
import metin2_map_b3                               from '../../images/maps/metin2_map_b3.jpg'
import metin2_map_BayBlackSand                     from '../../images/maps/metin2_map_BayBlackSand.jpg'
import metin2_map_c1                               from '../../images/maps/metin2_map_c1.jpg'
import metin2_map_c3                               from '../../images/maps/metin2_map_c3.jpg'
import Metin2_map_CapeDragonHead                   from '../../images/maps/Metin2_map_CapeDragonHead.jpg'
import metin2_map_dawnmist_dungeon_01              from '../../images/maps/metin2_map_dawnmist_dungeon_01.jpg'
import metin2_map_dawnmistwood                     from '../../images/maps/metin2_map_dawnmistwood.jpg'
import metin2_map_devilsCatacomb                   from '../../images/maps/metin2_map_devilsCatacomb.jpg'
import metin2_map_deviltower1                      from '../../images/maps/metin2_map_deviltower1.jpg'
import metin2_map_e1                               from '../../images/maps/metin2_map_e1.jpg'
import metin2_map_guild_01                         from '../../images/maps/metin2_map_guild_01.jpg'
import metin2_map_guild_02                         from '../../images/maps/metin2_map_guild_02.jpg'
import metin2_map_guild_03                         from '../../images/maps/metin2_map_guild_03.jpg'
import metin2_map_milgyo                           from '../../images/maps/metin2_map_milgyo.jpg'
import metin2_map_monkeydungeon                    from '../../images/maps/metin2_map_monkeydungeon.jpg'
import metin2_map_monkeydungeon_02                 from '../../images/maps/metin2_map_monkeydungeon_02.jpg'
import metin2_map_monkeydungeon_03                 from '../../images/maps/metin2_map_monkeydungeon_03.jpg'
import metin2_map_Mt_Th_dungeon_01                 from '../../images/maps/metin2_map_Mt_Th_dungeon_01.jpg'
import metin2_map_n_desert_01                      from '../../images/maps/metin2_map_n_desert_01.jpg'
import metin2_map_n_flame_01                       from '../../images/maps/metin2_map_n_flame_01.jpg'
import metin2_map_n_flame_dungeon_01               from '../../images/maps/metin2_map_n_flame_dungeon_01.jpg'
import metin2_map_n_snow_dungeon_01                from '../../images/maps/metin2_map_n_snow_dungeon_01.jpg'
import metin2_map_nusluck01                        from '../../images/maps/metin2_map_nusluck01.jpg'
import metin2_map_privateshop                      from '../../images/maps/metin2_map_privateshop.jpg'
import metin2_map_skipia_dungeon_01                from '../../images/maps/metin2_map_skipia_dungeon_01.jpg'
import metin2_map_skipia_dungeon_02                from '../../images/maps/metin2_map_skipia_dungeon_02.jpg'
import metin2_map_spiderdungeon                    from '../../images/maps/metin2_map_spiderdungeon.jpg'
import metin2_map_spiderdungeon_02                 from '../../images/maps/metin2_map_spiderdungeon_02.jpg'
import metin2_map_spiderdungeon_03                 from '../../images/maps/metin2_map_spiderdungeon_03.jpg'
import metin2_map_trent                            from '../../images/maps/metin2_map_trent.jpg'
import metin2_map_trent02                          from '../../images/maps/metin2_map_trent02.jpg'
import metin2_map_WL_01                            from '../../images/maps/metin2_map_WL_01.jpg'
import store                                       from '../../store';
import auth                                        from '../../utils/auth'
import { ACTIONS }                                 from '../../utils/enums.js'
import { getNiceLookingStringFromMapName }         from '../../utils/functions'
import {
    HackbarAccordion,
    HackbarButton,
    HackbarCheckbox,
    HackbarPaper,
    HackbarSelect
}                                                  from '../hackbar_style/hackbar_style.js'
import MobShower                                   from '../hacks/mob_shower/mob_shower';
import './metinclientmap.css'

const MAPS = {
    metin2_map_a1: new Image().src = metin2_map_a1,
    metin2_map_a3: new Image().src = metin2_map_a3,
    metin2_map_b1: new Image().src = metin2_map_b1,
    metin2_map_b3: new Image().src = metin2_map_b3,
    metin2_map_c1: new Image().src = metin2_map_c1,
    metin2_map_c3: new Image().src = metin2_map_c3,
    map_a2: new Image().src = map_a2,
    map_n_snowm_01: new Image().src = map_n_snowm_01,
    metin2_guild_village_01: new Image().src = metin2_guild_village_01,
    metin2_guild_village_02: new Image().src = metin2_guild_village_02,
    metin2_guild_village_03: new Image().src = metin2_guild_village_03,
    Metin2_map_CapeDragonHead: new Image().src = Metin2_map_CapeDragonHead,
    metin2_map_BayBlackSand: new Image().src = metin2_map_BayBlackSand,
    metin2_map_dawnmist_dungeon_01: new Image().src = metin2_map_dawnmist_dungeon_01,
    metin2_map_dawnmistwood: new Image().src = metin2_map_dawnmistwood,
    metin2_map_devilsCatacomb: new Image().src = metin2_map_devilsCatacomb,
    metin2_map_deviltower1: new Image().src = metin2_map_deviltower1,
    metin2_map_e1: new Image().src = metin2_map_e1,
    metin2_map_guild_01: new Image().src = metin2_map_guild_01,
    metin2_map_guild_02: new Image().src = metin2_map_guild_02,
    metin2_map_guild_03: new Image().src = metin2_map_guild_03,
    metin2_map_monkeydungeon_02: new Image().src = metin2_map_monkeydungeon_02,
    metin2_map_monkeydungeon_03: new Image().src = metin2_map_monkeydungeon_03,
    metin2_map_monkeydungeon: new Image().src = metin2_map_monkeydungeon,
    metin2_map_Mt_Th_dungeon_01: new Image().src = metin2_map_Mt_Th_dungeon_01,
    metin2_map_Mt_Thunder: new Image().src = metin2_map_n_flame_01,
    metin2_map_n_desert_01: new Image().src = metin2_map_n_desert_01,
    metin2_map_n_flame_01: new Image().src = metin2_map_n_flame_01,
    metin2_map_n_flame_dungeon_01: new Image().src = metin2_map_n_flame_dungeon_01,
    metin2_map_n_snow_dungeon_01: new Image().src = metin2_map_n_snow_dungeon_01,
    metin2_map_nusluck01: new Image().src = metin2_map_nusluck01,
    metin2_map_privateshop: new Image().src = metin2_map_privateshop,
    metin2_map_skipia_dungeon_01: new Image().src = metin2_map_skipia_dungeon_01,
    metin2_map_skipia_dungeon_02: new Image().src = metin2_map_skipia_dungeon_02,
    metin2_map_spiderdungeon: new Image().src = metin2_map_spiderdungeon,
    metin2_map_spiderdungeon_02: new Image().src = metin2_map_spiderdungeon_02,
    metin2_map_spiderdungeon_03: new Image().src = metin2_map_spiderdungeon_03,
    metin2_map_trent: new Image().src = metin2_map_trent,
    metin2_map_trent02: new Image().src = metin2_map_trent02,
    metin2_map_WL_01: new Image().src = metin2_map_WL_01,
    metin2_map_milgyo: new Image().src = metin2_map_milgyo,
}

class MetinClientMap extends React.Component {
    constructor( props ) {
        super(props)
        this.state = {
            scaleIndex: 0,
            scaleList: { 0: [ 700, 1 ], 1: [ 500, 1 ], 2: [ 200, 1 ], 3: [ 200, 0.5 ], 4: [200, 0.25]},
            showInstancesList: true,
            showFarmbotWaypoints: true,
            showWaithack: true,
            showPickup: true,
            showGrid: false,
            followPlayer: true,
            openMenu: false,
            anchorElMenu: null,
            instances: [],
            xOff: 0,
            yOff: 0,
            xMoved: 0,
            yMoved: 0,
            dimensions: { height: 0, width: 0 },
            CurrentMap: 'None',
            expandedSchema: false,
            selected_mob: {},
            dropdownMapName: '',
            renderMap: true,
        }
    }

    strToBool = ( str ) => {
        if ( str === 'true' || str === true ) {
            return true
        }
        if ( str === 'false' || str === false ) {
            return false
        }
    }

    componentDidMount() {
        let scale_index = auth.get('scaleIndex')
        if ( !Object.keys(scale_index).length ) {
            scale_index = 0
        }
        let showInstancesList = auth.get('showInstancesList')
        if ( !Object.keys(showInstancesList).length ) {
            showInstancesList = true
        }
        let showWaithack = auth.get('showWaithack')
        if ( !Object.keys(showWaithack).length ) {
            showWaithack = true
        }
        let showPickup = auth.get('showPickup')
        if ( !Object.keys(showPickup).length ) {
            showPickup = true
        }
        let showGrid = auth.get('showGrid')
        if ( !Object.keys(showGrid).length ) {
            showGrid = false
        }
        let followPlayer = auth.get('followPlayer')
        if ( !Object.keys(followPlayer).length ) {
            followPlayer = false
        }
        
        this.setState({
            ...this.state, scaleIndex: parseInt(scale_index),
            showInstancesList: this.strToBool(showInstancesList),
            showWaithack: this.strToBool(showWaithack),
            showPickup: this.strToBool(showPickup),
            showGrid: this.strToBool(showGrid),
            followPlayer: this.strToBool(followPlayer)
        }, this.calculateCurrentOffset)

    }

    onChangeOpenMenu = ( event ) => {
        this.setState({ ...this.state, openMenu: true, anchorElMenu: event.target })
    }

    onChangeScale = ( action ) => {
        if ( action === 'previous' ) {
            if ( this.state.scaleIndex + 1 >= Object.keys(this.state.scaleList).length ) {
                this.setState({
                    ...this.state,
                    scaleIndex: 0,
                });
                auth.set('0', 'scaleIndex', true)

            } else {
                this.setState({
                    ...this.state,
                    scaleIndex: this.state.scaleIndex + 1,
                });
                let new_int = this.state.scaleIndex + 1
                let new_string = new_int.toString()
                auth.set(new_string, 'scaleIndex', true)

            }
        } else if ( action === 'next' ) {
            if ( this.state.scaleIndex - 1 < 0 ) {
                this.setState({
                    ...this.state,
                    scaleIndex: Object.keys(this.state.scaleList).length - 1,
                });
                let new_int = Object.keys(this.state.scaleList).length - 1
                let new_string = new_int.toString()
                auth.set(new_string, 'scaleIndex', true)
            } else {
                this.setState({
                    ...this.state,
                    scaleIndex: this.state.scaleIndex - 1,
                });
                let new_int = this.state.scaleIndex - 1
                let new_string = new_int.toString()
                auth.set(new_string, 'scaleIndex', true)
            }
        }
    }
    drawInstance = ( { x, y, width, height, id } ) => {
        if ( this.props.character_status.CurrentMap === this.state.CurrentMap ) {
            let color_to_display = "#f00"
            if ( id.type == 1 ) {
                color_to_display = '#00e11a'
            } else if ( id.type == 2 ) {
                color_to_display = '#B803ff'
                width *= 3
                height *= 3
            } else if ( id.type == 3 ) {
                color_to_display = '#1033df'
            } else if ( id.type == 6 ) {
                if ( id.vid !== this.props.character_status.vid ) {
                    color_to_display = '#d9ff12'
                } else {
                    color_to_display = '#fff'
                }
            }

            return ( <Rect
                x={ x }
                y={ y }
                x2={ x + width }
                y2={ y + height }
                color={ color_to_display }
                fill={ true }/> )
        }

    }
    drawFarmbotWaypoint = ( { x, y, width, height, id } ) => {
        if(this.state.dropdownMapName){
            if(this.state.dropdownMapName === id.instance[2]){
                return(
                    <>
                    <Circle
                        x={ x }
                        y={ y }
                        radius={ width }
                        color="#fff"
                        fill={ false }
                    />
                    <Text x={ x - 2 } y={ y } font='34px Times New Roman' color="#fff"> { id.id } </Text>
                </>
                    )
            }


        }
        else{
            if ( this.state.CurrentMap === id.instance[2] ) {
                return (
                    <>
                        <Circle
                            x={ x }
                            y={ y }
                            radius={ width }
                            color="#fff"
                            fill={ false }
                        />
                        <Text x={ x - 2 } y={ y } font='34px Times New Roman' color="#fff"> { id.id } </Text>
                    </>
                )
            }
        }


    }
    drawWaithackRangeCircle = ( { x, y, width, height, id } ) => {
        if ( this.props.character_status.CurrentMap === this.state.CurrentMap ) {
            return (
                <>
                    <Circle
                        x={ x }
                        y={ y }
                        radius={ width }
                        color="#f00"
                        fill={ false }
                    />

                </>
            )
        }

    }
    drawPickupRangeCircle = ( { x, y, width, height, id } ) => {
        if ( this.props.character_status.CurrentMap === this.state.CurrentMap ) {
            return ( <Circle
                x={ x }
                y={ y }
                radius={ width }
                color="#fff"
                fill={ false }
            /> )
        }

    }
    onMapMoved = ( cell_x, cell_y ) => {

        this.setState({ ...this.state, xMoved: cell_x, yMoved: cell_y })
    }
    onMapClick = ( x, y, button, rawX, rawY ) => {
        //console.log(this.instances)
        console.log(button)
        for ( const element of this.instances ) {
            if ( x >= element.cellX && y >= element.cellY && x <= element.cellX + element.cellWidth && y <= element.cellY + element.cellHeight ) {
                if ( element.id === undefined ) {
                    return
                }
                if ( element.id.id === 1 ) {
                    return
                }
                //console.log(element.id)
                this.setState({ ...this.state, selected_mob: element.id })
                return true
            }
        }

        if ( button === ButtonTypes.LEFT ) {
            this.setState({ ...this.state, selected_mob: {} })
            store.dispatch({
                type: ACTIONS.WALK_TO_POSITION,
                client: this.props.socket,
                index: [ [ ( x + this.state.xOff ) * 100, ( y + this.state.yOff ) * 100 ], this.state.dropdownMapName ? this.state.dropdownMapName : this.state.CurrentMap ],
                payload: { client_id: store.getState().receivePacketsReducer.selected_client_id }
            })
        } else if ( button === ButtonTypes.MIDDLE) {
            this.setState({ ...this.state, selected_mob: {} })
            store.dispatch({
                type: ACTIONS.TELEPORT_TO_POSITION,
                client: this.props.socket,
                index: [ [ ( x + this.state.xOff ) * 100, ( y + this.state.yOff ) * 100 ], this.state.dropdownMapName ? this.state.dropdownMapName : this.state.CurrentMap ],
                payload: { client_id: store.getState().receivePacketsReducer.selected_client_id }
            })
        } else if ( button === ButtonTypes.RIGHT ) {
            //console.log('tha')
            let farmbot_status = this.props.hack_status.FarmBot
            let new_path = farmbot_status.Path
            let point = [ ( x + this.state.xOff ) * 100, ( y + this.state.yOff ) * 100, this.state.dropdownMapName ? this.state.dropdownMapName : this.state.CurrentMap ]
            new_path.push(point)

            let _module = {
                Path: new_path,
            }
            //console.log(_module)
            store.dispatch({
                type: ACTIONS.UPDATE_ONE_HACK_MODULE,
                client: this.props.socket,
                payload: { module_dict: _module, module_name: 'FarmBot' },
                index: store.getState().receivePacketsReducer.selected_client_id
            })
        }
    }

    loadCharacterCurrentMap = () => {
        let CurrentMap = this.props.character_status.CurrentMap
        let img = new Image();
        img.src = this.getMapByName(CurrentMap)
        img.onload = () => {
            this.setState(
                {
                    ...this.state,
                    dimensions: {
                        height: img.height,
                        width: img.width
                    },
                    CurrentMap: CurrentMap,
                    dropdownMapName: '',
                    renderMap: false
                }, this.calculateCurrentOffset);
        };
    }
    loadMapByName = ( map_name ) => {
        if(this.props.character_status.CurrentMap === map_name){
           return this.loadCharacterCurrentMap() 
        }

        let CurrentMap = map_name
        let img = new Image();
        img.src = this.getMapByName(CurrentMap)

        img.onload = () => {
            this.setState(
                {
                    ...this.state,
                    dimensions: {
                        height: img.height,
                        width: img.width
                    },
                    dropdownMapName: CurrentMap,
                    renderMap: false
                }, this.calculateCurrentOffset)
        };

    }
    switchShowInstancesList = () => {
        this.setState({
            ...this.state,
            showInstancesList: !this.state.showInstancesList
        })
        let new_bool = !this.state.showInstancesList
        let new_string = new_bool.toString()
        auth.set(new_string, 'showInstancesList', true)
    }
    switchShowWaithackRange = () => {
        this.setState({
            ...this.state,
            showWaithack: !this.state.showWaithack
        });
        let new_bool = !this.state.showWaithack
        let new_string = new_bool.toString()
        auth.set(new_string, 'showWaithack', true)
    }
    switchShowPickupRange = () => {
        this.setState({
            ...this.state,
            showPickup: !this.state.showPickup
        });
        let new_bool = !this.state.showPickup
        let new_string = new_bool.toString()
        auth.set(new_string, 'showPickup', true)
    }
    switchShowFarmbotWaypoints = () => {
        this.setState({
            ...this.state,
            showFarmbotWaypoints: !this.state.showFarmbotWaypoints
        });
    }
    switchShowGrid = () => {
        this.setState({ ...this.state, showGrid: !this.state.showGrid })
        let new_bool = !this.state.showGrid
        let new_string = new_bool.toString()
        auth.set(new_string, 'showGrid', true)
    }
    switchShowPlayer = () => {
        this.setState({ ...this.state, followPlayer: !this.state.followPlayer })
        let new_bool = !this.state.followPlayer
        let new_string = new_bool.toString()
        auth.set(new_string, 'followPlayer', true)
        if(new_bool){
            this.props.forceRefresh()
        }
    }

    onCloseMenu = () => {
        this.setState({ ...this.state, openMenu: false, anchorElMenu: null })
    }

    getMapByName( map_name ) {
        return MAPS[map_name]
    }

    switchExpandedSchema = () => {
        this.setState({ ...this.state, expandedSchema: !this.state.expandedSchema })
    }
    getSelectedMobName = () => {
        if ( this.state.selected_mob.type !== 6 ) {
            return this.props.mobs_list[this.state.selected_mob.id].name
        } else if ( this.state.selected_mob.type === 6 ) {
            return this.state.selected_mob.name
        }

    }

    calculateCurrentOffset = () => {
        if(!Object.keys(this.props.character_status).length){
            return
        }
        let realCellSize = this.state.scaleList[this.state.scaleIndex][0] * ( this.state.scaleList[this.state.scaleIndex][1] / 100 )
        
        if(this.state.followPlayer){

            let new_xOff = this.props.character_status.Position[0] / 100 - ( 935 / realCellSize / 2 )
            let new_yOff = this.props.character_status.Position[1] / 100 - ( 700 / realCellSize / 2 )

            if(this.state.xOff === new_xOff && this.state.yOff === new_yOff || this.state.dropdownMapName){
                return
            }

            this.setState({...this.state,
                xOff: this.props.character_status.Position[0] / 100 - ( 935 / realCellSize / 2 ),
                yOff: this.props.character_status.Position[1] / 100 - ( 700 / realCellSize / 2 )
            })
        }
        else{
            let new_xOff = this.state.dimensions.width / 2 - ( 935 / realCellSize / 2 )
            let new_yOff = this.state.dimensions.height / 2 - ( 700 / realCellSize / 2 )


            this.setState({...this.state,
                xOff: new_xOff,
                yOff: new_yOff
            })

        }
        
    }

    render = () => {
        if ( this.props.character_status.CurrentMap && this.props.hack_status ) {
            this.instances = []
            this.farmbot_waypoints = []

            if(this.state.followPlayer){
                this.calculateCurrentOffset()
            }

            if ( this.state.CurrentMap === 'None' || this.props.character_status.CurrentMap !== this.state.CurrentMap && this.state.followPlayer ) {
                this.loadCharacterCurrentMap()
            }

            let draw_instances_list = <> </>
            let farmbot_waypoints_list = <> </>
            let waithack_circle = <> </>
            let pickup_circle = <> </>

            if ( !this.state.dropdownMapName ) {
                if ( this.state.showInstancesList ) {
                    this.props.instances_list.map(
                        ( instance, i ) => {
                            if ( instance.type !== 5 ) {
                                this.instances.push({
                                    cellX: Math.round(instance.x / 100 - this.state.xOff),
                                    cellY: Math.round(instance.y / 100 - this.state.yOff),
                                    cellWidth: 2,
                                    cellHeight: 2,
                                    id: instance
                                })
                            }
                        })
                    draw_instances_list = <LayerRaw cells={ this.instances } drawFunc={ this.drawInstance }/>
                }

                if ( this.state.showWaithack && this.props.hack_status ) {
                    waithack_circle = <LayerRaw cells={ [ {
                        cellX: this.props.character_status.Position[0] / 100 - this.state.xOff,
                        cellY: this.props.character_status.Position[1] / 100 - this.state.yOff,
                        cellWidth: this.props.hack_status.WaitHack.Range / 100
                    } ] } drawFunc={ this.drawWaithackRangeCircle }/>
                }
                if ( this.state.showPickup && this.props.hack_status ) {
                    pickup_circle = <LayerRaw cells={ [ {
                        cellX: this.props.character_status.Position[0] / 100 - this.state.xOff,
                        cellY: this.props.character_status.Position[1] / 100 - this.state.yOff,
                        cellWidth: this.props.hack_status.Settings.PickupRange / 100
                    } ] } drawFunc={ this.drawPickupRangeCircle }/>
                }
                if ( this.state.showGrid && this.props.hack_status ) {
                    this.maxCellY = this.state.dimensions.height - this.state.yOff
                    this.maxCellX = this.state.dimensions.width - this.state.xOff
                } else if ( !this.state.showGrid && this.props.hack_status ) {
                    this.maxCellX = -this.state.xOff
                    this.maxCellY = -this.state.yOff
                }
            }
            if ( this.state.showFarmbotWaypoints && this.props.hack_status.FarmBot.Path ) {
                this.props.hack_status.FarmBot.Path.map(
                    ( instance, i ) => {
                        this.farmbot_waypoints.push({
                            cellX: Math.round(instance[0] / 100 - this.state.xOff),
                            cellY: Math.round(instance[1] / 100 - this.state.yOff),
                            cellWidth: 3,
                            cellHeight: 2,
                            id: { instance: instance, id: i + 1 }
                        })
                    })
                farmbot_waypoints_list =
                    <LayerRaw cells={ this.farmbot_waypoints } drawFunc={ this.drawFarmbotWaypoint }/>
            }
            return (
                <Grid container className={ 'metin-client-map' }>
                    
                    { this.state.renderMap &&
                        <>
                    <Canvas width={ 955 } height={ 700 }>
                        <Map x={ 10 } y={ 10 }
                             zoomType={ { type: 'NONE' } }
                             width={ this.state.dimensions.width }
                             height={ this.state.dimensions.height }
                             cellSize={ this.state.scaleList[this.state.scaleIndex][0] }
                             zoom={ this.state.scaleList[this.state.scaleIndex][1] }
                             minCellX={ -this.state.xOff } minCellY={ -this.state.yOff }
                             maxCellX={ this.maxCellX } maxCellY={ this.maxCellY }
                             renderLayersToImage={ true }
                             onClick={ ( x, y, button, rawX, rawY ) => this.onMapClick( x, y, button, rawX, rawY) }>
                            <Layer>
                                <LayerImage xOff={ -this.state.xOff } yOff={ -this.state.yOff }
                                            src={ this.state.dropdownMapName
                                                  ? this.getMapByName(this.state.dropdownMapName)
                                                  : this.getMapByName(this.state.CurrentMap) } x={ 0 } y={ 0 }
                                            width={ this.state.dimensions.width }
                                            height={ this.state.dimensions.height }/>
                            </Layer>
                            <Layer>
                                { draw_instances_list }
                            </Layer>
                            <Layer>
                                { farmbot_waypoints_list }
                            </Layer>
                            <Layer>
                                { waithack_circle }
                            </Layer>
                            <Layer>
                                { pickup_circle }
                            </Layer>
                        </Map>
                    </Canvas>
                    <Grid container>
                        <HackbarPaper className='mapOptionManager'>
                            <Grid item xs={ 12 }>
                                <HackbarSelect
                                    value={ this.state.dropdownMapName ?
                                            this.state.dropdownMapName :
                                            this.state.CurrentMap }
                                    onChange={ ( e ) => {
                                        this.loadMapByName(e.target.value)
                                    } }
                                    className={ 'select-map-client-map' }
                                    fullWidth
                                >
                                    <MenuItem
                                        value={ this.props.character_status.CurrentMap }> { this.props.language.current_map } </MenuItem>
                                    <MenuItem
                                        value={ 'metin2_map_a1' }> { getNiceLookingStringFromMapName('metin2_map_a1') } </MenuItem>
                                    <MenuItem
                                        value={ 'metin2_map_a3' }> { getNiceLookingStringFromMapName('metin2_map_a3') } </MenuItem>
                                    <MenuItem
                                        value={ 'metin2_map_guild_01' }> { getNiceLookingStringFromMapName('metin2_map_guild_01') } </MenuItem>
                                    <MenuItem
                                        value={ 'metin2_map_b1' }> { getNiceLookingStringFromMapName('metin2_map_b1') } </MenuItem>
                                    <MenuItem
                                        value={ 'metin2_map_b3' }>{ getNiceLookingStringFromMapName('metin2_map_b3') } </MenuItem>
                                    <MenuItem
                                        value={ 'metin2_map_guild_02' }> { getNiceLookingStringFromMapName('metin2_map_guild_02') } </MenuItem>
                                    <MenuItem
                                        value={ 'metin2_map_c1' }> { getNiceLookingStringFromMapName('metin2_map_c1') } </MenuItem>
                                    <MenuItem
                                        value={ 'metin2_map_c3' }> { getNiceLookingStringFromMapName('metin2_map_c3') } </MenuItem>
                                    <MenuItem
                                        value={ 'metin2_map_guild_03' }> { getNiceLookingStringFromMapName('metin2_map_guild_03') } </MenuItem>
                                    <MenuItem
                                        value={ 'map_a2' }> { getNiceLookingStringFromMapName('map_a2') } </MenuItem>
                                    <MenuItem
                                        value={ 'map_n_snowm_01' }> { getNiceLookingStringFromMapName('map_n_snowm_01') } </MenuItem>
                                    <MenuItem
                                        value={ 'metin2_map_n_desert_01' }> { getNiceLookingStringFromMapName('metin2_map_n_desert_01') } </MenuItem>
                                    <MenuItem
                                        value={ 'metin2_map_n_flame_01' }> { getNiceLookingStringFromMapName('metin2_map_n_flame_01') } </MenuItem>
                                    <MenuItem
                                        value={ 'metin2_map_monkeydungeon' }> { getNiceLookingStringFromMapName('metin2_map_monkeydungeon') } </MenuItem>
                                    <MenuItem
                                        value={ 'metin2_map_monkeydungeon_02' }> { getNiceLookingStringFromMapName('metin2_map_monkeydungeon_02') } </MenuItem>
                                    <MenuItem
                                        value={ 'metin2_map_monkeydungeon_03' }> { getNiceLookingStringFromMapName('metin2_map_monkeydungeon_03') } </MenuItem>
                                </HackbarSelect>
                            </Grid>
                            <Grid container>
                                <Grid item xs={ 3 } style={ { textAlign: 'center' } }>
                                    <IconButton onClick={ e => this.onChangeOpenMenu(e) }>
                                        <MenuIcon style={ { color: 'white' } }/>
                                    </IconButton>
                                    <Menu open={ Boolean(this.state.openMenu) } onClose={ () => this.onCloseMenu() }
                                          anchorEl={ this.state.anchorElMenu }>
                                        <MenuItem disabled> { this.props.language.map_options } </MenuItem>
                                        <MenuItem>
                                            <HackbarCheckbox checked={ this.state.followPlayer }
                                                             onChange={ () => this.switchShowPlayer() }/>
                                            { this.props.language.label_follow_player }
                                        </MenuItem>
                                        <MenuItem>
                                            <HackbarCheckbox checked={ this.state.showInstancesList }
                                                             onChange={ () => this.switchShowInstancesList() }/>
                                            { this.props.language.label_show_instances }
                                        </MenuItem>
                                        <MenuItem>
                                            <HackbarCheckbox checked={ this.state.showWaithack }
                                                             onChange={ () => this.switchShowWaithackRange() }/>
                                            { this.props.language.label_show_waithack_range }
                                        </MenuItem>
                                        <MenuItem>
                                            <HackbarCheckbox checked={ this.state.showPickup }
                                                             onChange={ () => this.switchShowPickupRange() }/>
                                            <Typography>{ this.props.language.label_show_pickup_range }</Typography>
                                        </MenuItem>
                                        <MenuItem>
                                            <HackbarCheckbox checked={ this.state.showGrid }
                                                             onChange={ () => this.switchShowGrid() }
                                            /><Typography> { this.props.language.label_show_grid }</Typography>
                                        </MenuItem>

                                    </Menu>
                                </Grid>
                                <Grid item xs={ 9 }>
                                    <ButtonGroup>
                                        <HackbarButton onClick={ () => this.onChangeScale('next') }> + </HackbarButton>
                                        <HackbarButton
                                            onClick={ () => this.onChangeScale('previous') }> - </HackbarButton>
                                        <HackbarButton onClick={ () => 
                                            {this.setState({...this.state, renderMap: false})
                                            if(this.state.followPlayer){
                                                this.loadCharacterCurrentMap()}
                                            }
                                            
                                            }> <GpsFixed/>
                                        </HackbarButton>
                                    </ButtonGroup>
                                </Grid>
                                <Grid item xs={ 12 }>
                                    <HackbarAccordion expanded={ this.state.expandedSchema }
                                                      onChange={ () => this.switchExpandedSchema(1) } fullWidth>
                                        <AccordionSummary>
                                            { !Object.keys(this.state.selected_mob).length
                                              ?
                                              (
                                                  <Typography> { this.props.language.label_no_mob_selected } </Typography>
                                              )
                                              :
                                              (
                                                  <Typography> { this.getSelectedMobName() } </Typography>
                                              )
                                            }
                                        </AccordionSummary>
                                        <AccordionDetails>
                                            <MobShower language={ this.props.mob_shower_language }
                                                       socket={ this.props.socket }
                                                       mob_shower={ this.props.hack_status.InstanceInteractions }
                                                       instance={ this.state.selected_mob }
                                                       item_list={ this.props.item_list }/>
                                        </AccordionDetails>
                                    </HackbarAccordion>
                                </Grid>


                            </Grid>
                        </HackbarPaper>
                    </Grid>
                        </>
                    }
                    { !this.state.renderMap && 
                        this.setState({
                            ...this.state,
                            renderMap: true
                        })
                    }

                </Grid>

            )
        }
        return (
            <>
                Cannot load map :(
            </>
        )
    }
}

export default MetinClientMap